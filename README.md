#Путеводитель по БЭМ технологиям и пример приложения на i-bem с любым бек-эндом

В Яндексе и некоторых других крупных организациях фронтэнд построен на стеке технологий БЭМ. В мире довольно популярна организация CSS с помощью методологии БЭМ. Она достаточно простая и не требует никаких дополнительных инструментов для ее реализации. Однако, CSS организация по БЭМ — это только верхушка айсберга, и действительно большую выгоду от БЭМ можно получить, используя весь стек технологий БЭМ или его часть.
<img src="https://habrastorage.org/files/344/91f/f9a/34491ff9ab5d4b6993941ef96220056b.jpg"/>

На сайте https://ru.bem.info/ вас встретят буквально с десяток технологий. Почитав о них, можно так и не понять, какие из них будут полезны в вашем проекте и как начать их использовать. В этой статье мы проведём краткий обзор многообразия БЭМ технологий, а также конкретный пример использования некоторых простых частей на проекте с произвольным бэкендом (Ruby on Rails, Django и т.д.)

<cut/>

#Карта БЭМ

###Методология

Методология вводит правила формирования верстки из блоков, выделения внутренних элементов блоков, а также правила повторного использования блоков с заданными модификациями поведения или внешнего вида. Подробнее почитать о ней можно [тут](https://ru.bem.info/method/).

###i-bem

С помощью JavaScript фреймворка i-bem клиентский JavaScript проекта разбивается на отдельные компоненты. *Применим только тогда, когда верстка проекта разбита на блоки по БЭМ методологии*. По базовым идеям i-bem похож на виджеты из jQuery UI или на Backbone View. У блока может быть несколько экземпляров. Каждый экземпляр имеет API для взаимодействия, может генерировать события, подписываться на события, иметь методы, которые вызываются при инициализации или уничтожении блока.

Инициализация компонентов происходит следующим образом. После загрузки html страницы и кода i-bem ищет все DOM-узлы с классом `i-bem` и сопоставляет дополнительные классы на этом узле с заданными декларациями блоков в JS.

Например, пусть имеется декларация
```javascript
BEM.DOM.decl('my-block', {...});
```
,тогда i-bem, найдя DOM-узлы с классом `i-bem`, отберет из них те, у которых в классах также присутствует класс `my-block`. Затем у каждого такого DOM-узла проверит наличие в атрибуте `data-bem` значения вида `"my-block": {...}"`. Если все проверки прошли успешно, значит этому DOM-узлу соответствует `i-bem` блок, и он будет проинициализирован.

До инициализации блока:
```HTML
<div class="my-block i-bem" data-bem="{'my-block':''}">Мой блок</div>
```
После:
```HTML
<div class="my-block i-bem my-block_js_inited" data-bem="{'my-block':''}">Мой блок</div>
```

###YModules

До принятия стандарта ES2015 для JavaScript использовалось два основных способа представления кода в виде модулей: AMD и Common.js. YModules  — AMD подобная библиотека описания модулей. Единственным отличием от AMD является наличие функции provide. Вызов функции provide внутри блока означает, что модуль готов к работе. Использование таких функций позволяет асинхронно загружать и инициализировать модули.

YModules используется в проектах Яндекса (например, API Карт), и в библиотеках bem-core и bem-components. Эти библиотеки содержат базовый набор готовых компонентов для построения клиентской части сервисов и разбиты на модули с помощью YModules.

###Bem-core

Bem-core содержит фреймворк i-bem, необходимые для работы i-bem модули (модули работы со строками, URI, промисы, observable и т.д.) и некоторые другие вещи, упрощающие написание i-bem компонентов. В примере без bem-core не обойтись, так как i-bem отдельно от него не поставляется.

###Bem components

Эта библиотека во многом похожа на Twitter Bootstrap. Она содержит стили, шаблоны и i-bem компоненты базовых элементов верстки, таких как кнопка, поле ввода, радио кнопка и т.д. По сути это дополнительные стили и API стандартных html компонентов input, text area, radio button, button и т.д. В библиотеке две темы оформления — реализующая дизайн Яндекса тема "islands" и "simple". Есть возможность подключения своих тем.

###BEMHTML, BH, BEMJSON

BEMHTML и BH — шаблонизаторы, генерирующие html код, написанный по правилам БЭМ методологии. Принимают на вход объект в формате BEMJSON. BEMJSON — это по сути JSON, написанный по определённым правилам. Вот пример.

BEMHTML шаблон:
```javascript
// Для каждого блока button выставляем тег button, а в качестве содержимого DOM узла — содержимое параметра text
block('button').tag()('button');
block('button').content()(function() {
    return this.ctx.text;
});
```
Входной BEMJSON:
```javascript
{
    block: 'button',
    text: 'Отправить'
}
```

Результат применения шаблонов на входной BEMJSON:
```HTML
<button class="button">Отправить</button>
```

Попробовать BEMHTML онлайн можно [тут](https://bem.github.io/bem-xjst/), BH — [тут](http://bem.github.io/bh).

BEMHTML и BH — схожие шаблонизаторы. Мы не будем их использовать в примере, поскольку наибольшая выгода от использования появляется в случае наличия JavaScript на серверной стороне и/или подключенной библиотеки блоков типа bem-components.

###Сборка ENB, bem-tools

ENB и bem-tools — Node.js модули для сборки js и css блоков в один или несколько итоговых файлов (бандлов). Бандлы подключаются на html страницу. ENB и bem-tools являются прямыми аналогами webpack и частично gulp, grunt. Эти библиотеки диктуют определенную файловую структуру фронтэнда. В зависимости от потребностей проекта у вас может быть папка блоков для настольной версии сайта, планшетной, мобильной версии и папка общих блоков, которые могут использоваться как в настольной, так и в мобильной версии. В простейшем случае у вас будет только одна папка с папками блоков внутри.

Оба сборщика учитывают зависимости между блоками. Это позволяет включать в итоговый код стили и скрипты только тех блоков, которые действительно используются в верстке, что бывает полезно, когда в проекте используется большая библиотека компонентов типа bem-components.

Bem-tools и ENB оба содержат в себе технологии сборки файлов, но отличаются способом написания конфигурации сборки. Bem-tools также содержит инструмент командной строки для создания css, js файлов блоков, элементов и модификаторов с соответствующим названием и расположением в файловой системе.

Скорей всего вы захотите использовать ENB: конфигурация сборки проекта у него проще и он постоянно развивается. Создание правильной файловой структуры проекта — задача несложная и для этого совершенно необязательно использовать bem-tools. Типичная структура блока:

```
blocks      // папка с блоками
  my-block/         // папка с файлами блока my-block
    __elem/         // папка для файлов элемента elem блока my-block
       my-block__elem.js
       my-block__elem.css
    my-block.js
    my-block.deps.js    // зависимости блока от элементов и др. блоков
    my-block.css
```

Стоит написать два слова про deps.js

###Borschick

Borschick выполняет функции постпроцессора (от части аналог Rework, PostCSS). Позволяет производить пост-обработку стилей и скриптов. С его помощью можно настроить объединение картинок в спрайты, минификацию, замену переменных и т.д. В примере мы не будем использовать этот инструмент, т.к. нам понадобятся только функции минификации, которые уже будут в технологиях сборки js и css.

#Практический пример
Давайте посмотрим, как вышеописанные технологии совместно могут дать удобный и адаптированный для работы в команде подход для разработки фронтэнда. Мы будем использовать БЭМ-методологию, bem-core (i-bem + YModules), ENB.

Полный код примера [тут](https://github.com/DimitryDushkin/bem-light-example). Для примера рассмотрим страницу немного нетипичного сайта недвижимости, содержащего объявления о продаже сказочных домов:

<img src="https://habrastorage.org/files/e09/9b1/930/e099b1930f9540ff92abb2765f120280.jpg"/>
<br>
Мы реализуем следующие функции:

- кнопку показа телефона для звонка;
- кнопку сокрытия объявления из выдачи;
- фильтр выдачи по типу продаваемой недвижимости, поддерживающий множественный выбор.

Заметим, что страница сверстана с использованием методологии БЭМ для организации структуры и названия классов (*это необходимое условие для использования i-bem*). Мы не будем заострять внимание на деталях верстки (кроме тех, которые необходимы для работы i-bem), поскольку и так достаточно статей на эту тему.

Разработка ведется в папке `./src`. Собирать css и js можно вручную командой `node_modules/.bin/enb make` или командой `gulp`. В последнем случае стартует browser-sync, который запустит веб-сервер по адресу http://localhost:3000, а также будет автоматически обновлять страницу при изменении js или css файлов блоков.

Более подробную инструкции по сборке/запуску смотрите на [гитхабе](https://github.com/DimitryDushkin/bem-light-example).

###Кнопка показа телефона для звонка

*Здесь вы увидите,
как осуществляется привязка к событию клика;
как находить элементы внутри блока;
как изменять состояние блока путем смены классов (модификаторов);
куда положить данные для блока и как извлекать их;
как выглядят блоки без DOM представления.*

Поведение кнопки описано в блоке `property`. Привязка к событию клика по кнопке осуществляется так:

```javascript
// src/blocks/property/property.js
// ...
live: function() {
    this.liveBindTo('phone', click, function(e) {
        this._onPhoneClick(e);
    });
}
```

Для того, чтобы манипулировать DOM-узлом кнопки показа телефона, нужно сначала найти ее. Нашим контекстом является блок property, а она находится внутри него. Так что пишем:

```javascript
var phoneElem = this.elem('phone');
```

Для того, чтобы можно было найти кнопку с помощью this.elem, она должна иметь специальное название класса — `property__phone`. Это часть соглашений об именах классов, которые важны для работы i-bem.js.

После клика кнопка меняет свой вид (отображаются все цифры телефона и убирается рамка). Рамка убирается заменой одного дополнительного класса на другой, описывающих возможные состояния кнопки ("hidden" и "revealed"). В БЭМ это называется сменой модификаторов:

```javascript
…
// у DOM-узла кнопки удаляется класс property__phone_hidden
this.delMod(phoneElem, 'hidden');
// DOM-узлу кнопки добавляется класс property__phone_revealed
this.setMod(phoneElem, 'revealed');
```

Смена текста на кнопке:
```javascript
phoneElem.text(this.params.phone);
```

Откуда берутся params? Мы предварительно поместили их в html-вёрстку:
```HTML
<div class="property i-bem" data-bem=’{"property": { "phone": "8 (916) 978-12-32", "id": 1, "type": "apartment" }}’>
```

Также как будто отправляется событие в google analytics (мы имитируем отправку события с помощью console.log):

```javascript
GA.hit(this.getMod('type'), this.params.id);
```

Вышеприведенная строка кода демонстрирует еще пару полезных вещей. Во-первых, данные блока можно хранить не только в атрибуте data-bem, но и в модификаторе. В нашем примере это удобно для выделения различными стилями различных типов недвижимости. В вёрстке это выглядит так:

```HTML
<div class="property property_type_advert i-bem"> …</div>
```

Во-вторых, бывают блоки, которым не соответствуют никакие DOM-узлы. Например, блок GA (google analytics). Имена таких блоков принято начинать с префикса i (например, вышеупомянутый блок называется i-ga). Обертка такого блока выглядит значительно проще по сравнению с обычным: сравните блоки button и i-ga:

```javascript
modules.define('button', ['i-bem__dom'], function(provide, BEM) {
provide(BEM.decl('button', {}, {
…
```

и

```javascript
modules.define('i-ga', function(provide) {
    provide({
...
```

###Кнопка сокрытия объявления из выдачи

*Здесь вы увидите, как можно генерировать БЭМ-события и обрабатывать их.*

После нажатия на эту кнопку объявление становится невидимым. Для того, чтобы не усложнять код примера, будем скрывать объявление только до того момента, пока пользователь не обновит страницу. В html укажем, что поведение кнопки будет описываться блоком “button” (добавив класс `i-bem` и атрибут `data-bem`):

```HTML
<button class="button property__hide i-bem" data-bem="{'button': ''}">
```

После нажатия кнопка "Скрыть" генерирует БЭМ-событие "clicked". Это поведение опишем в блоке “button”:

```javascript
// src/blocks/button/button.js
// ...
    live: function() {
    // Подписываемся на обычное DOM событие click на DOM-узле этого блока
        this.liveBindTo('click', function() {
            this.emit('clicked');
        });
    }
…
```

Обрабатываться   БЭМ-событие “clicked” будет блоком “property”:

```javascript
// src/blocks/property/property.js
// …
    _onHideClick: function() {
       // DOM-узлу блока property добавляется класс property_hidden с display:none
       this.setMod('hidden');
},
// …
live: function() {
     // Подписываемся на BEM-событие clicked на блоке button,
     // который находится внутри DOM-узла этого блока (property)
     this.liveInitOnBlockInsideEvent('clicked', 'button', function(e) {
          this._onHideClick(e);
     });
}
```

###Фильтр выдачи по типу продаваемой недвижимости

*Здесь вы увидите, как
подключать к проекту внешние библиотеки,
получать доступ к данным одних блоков из других (с помощью публичных методов)*.

На странице слева от списка объявлений находится гибрид текстового поля и выпадающего списка. Если с помощью этого контрола (фильтра выдачи) выбрать один или несколько типов недвижимости, то отобразятся только объявления с соответствующим типом недвижимости.

Фильтр реализован с помощью внешней библиотеки [Selectize](http://selectize.github.io/selectize.js/). Поместим её в обертку — блок selectize. В selectize.deps.js пропишем зависимость от блока “jquery”, который включен в поставку bem-core:

```
({
    shouldDeps: { block: 'jquery' }
})
```

Блок jquery при инициализации сам скачает библиотеку, если она еще не скачивалась.

Сделаем два симлинка (т.е. ссылки) на фактическое расположение стилей и скриптов библиотеки в файлах `src/blocks/selectize/selectize.js` и `src/blocks/selectize.styl`. Сама библиотека устанавливается посредством bower.

Вёрстка будет выглядеть так:

```HTML
 <select class="property-type i-bem" data-bem='{"property-type": ""}'  placeholder="Тип недвижимости" multiple="multiple">
    <option></option>
    <option value="apartment">Квартира</option>
    …
```

Будем инициализировать selectize во время инициализации блока property-type:

```javascript
    onSetMod: {
        js: function() {
            this.domElem.selectize({
                delimiter: ',',
                persist: false,
                create: function(input) {
                    return {
                        value: input,
                        text: input
                    }
                }
            });
            this.bindTo('change', this._onChange);
        }
    },

    _onChange: function(e) {
        // Параллельно с каждым событием change генерируемым экземпляром selectize, будем генерировать БЭМ-событие propertyTypeChanged
        this.emit('propertyTypeChanged', $(e.target).val());
    }
```

В блоке properties-list, DOM-узел которого включает как фильтр выдачи, так и список объявлений, подпишемся на БЭМ-событие propertyTypeChanged. В функции-обработчике события `_onPropertyTypeChanged` найдем все объявления о продаже

```javascript
var properties = this.findBlocksInside('property');
```

и поставим модификаторы hidden только тем объявлениям, у которых тип недвижимости не совпадает ни с одним значением, выбранным в фильтре выдачи

```javascript
...
if (propertyTypes.indexOf(property.getType()) == -1) {
    property.setMod('hidden');
…
```

Обратите внимание на публичный метод блока property `getType`, с помощью которого осуществляется доступ к значению параметра type у объявления. Код блока property:

```javascript
getType: function() {
    return this.params.type;
}
```

#Заключение

Мы совершили небольшое путешествие по миру БЭМ-технологий, с углублением в сторону JavaScript-фреймворка i-bem. Рассмотрели пример, в котором используется лишь часть стека БЭМ-технологий: БЭМ-методология, bem-core (i-bem + YModules), ENB. Надеюсь, что вы сформировали для себя более четкое понимание того, из чего состоит БЭМ, как работает i-bem, и что стоит (или не стоит) попробовать использовать из стека БЭМ-технологий в вашем следующем проекте.

